# 게임 엔진 아키텍처를 읽고 배운 것 (5장)

- 게임 매니저 객체  
게임 엔진에 존재하는 다양한 매니저들은 서로 의존성을 가지고 있기에, 생성과 파괴의 순서가 보장되어야 한다. 그러나, C++의 생성자와 소멸자는 단순한 Singleton을 이용할 시, 그 순서가 보장되지 않는다. 그렇기에 'Init()', 'Shutdown()' 같은 함수를 만들어서 순서를 보장하는 것이 좋다. (한 발짝 더 나아가서, 모든 매니저의 부모가 되는 클래스나, 인터페이스를 만드는 것도 좋은 방법일 것 같다.)  
매니저를 관리하는 클래스를 만드는 것도 좋은 방법이다. 매니저들은 자신의 정보와 다른 매니저에 대한 의존 관계를 입력하게 하고 (이 역시 매니저 부모 클래스를 이용할 수 있을 것 같다), 초기화 시에 매니저 관리 클래스는 선행 초기화 작업을 한 후에, 매니저들 간의 의존성 그래프를 만든다. 그 후에 의존성 그래프를 검사해서 (DFS 알고리즘을 활용하면 될 것 같다) 매니저 생성 큐를 만든다. 이제 매니저 생성 큐의 순서를 따라 매니저를 생성하고, 그 순서를 반대로 하여 파괴하면 된다.

- 메모리 할당자
  - 동적 메모리의 할당은 매우 느린 작업이다. 그러므로 게임 엔진에서는 직접 할당자를 제작하여 쓴다. 이렇게 하면 미리 할당된 메모리 블록을 이용할 수 있고, 컨텍스트를 전환할 필요가 없어 빠른 할당을 할 수가 있다. 대표적인 할당자로는 스택 기반 할당자와 풀 할당자가 있다.  

  - 메모리 할당자는 정렬된 메모리를 반환할 수 있어야 한다. 방법은 간단하다. 정렬 조건 크기 + 요청 크기만큼을 할당한 후에, 시작주소가 정렬된 주소가 되도록 조정하여 반환하면 된다. 조정값은 처음 메모리 주소에서 가장 낮은 비트를 마스킹한 후에 정렬 조건에서 빼면 된다. 마스크는 정렬 조건에서 1을 빼면 얻을 수 있다. (정렬 조건이 항상 2의 제곱임을 이용) 결론적으로 정렬된 주소를 얻는 수식은 다음과 같다.  
  **정렬된 주소 = 주소 + (정렬 조건 - (주소 & (정렬 조건 - 1)))**

  - 그렇다면 정렬한 메모리는 어떻게 해제할 수 있을까? 메모리를 해제하기 위해서는 원래 주소를 얻어낼 필요가 있다. 그 방법은 간단하다. 바로 정렬을 위해서 추가로 할당한 메모리에 메타 정보를 저장하는 것이다. 주소를 정렬하면 최소 1바이트는 정렬하게 된다. 그리고 메타 정보는 1바이트면 충분하다 (조정값이 256을 넘을 수가 없기 때문이다.). 그렇기에 정렬된 주소보다 1바이트 앞에 메타 정보를 저장한다면, 쉽게 읽고 쓸 수 있을 것이다.  

  - 게임 루프 중에 임시 데이터 할당이 필요할 때가 있다. 이를 위해 단일 프레임 할당자를 만들 수 있다. 스택 할당자로 구성된 단일 프레임 할당자는 매 프레임마다 할당자를 초기화하는 방식을 통해서 해제를 신경 쓰지 않으면서도 굉장히 빠르게 할당 받을 수 있다. 그러나 한 프레임에만 유지된다는 단점이 존재한다. 이를 보완하는 방법은 간단하다. 단일 프레임 할당자를 2개 만들어서, 매 프레임마다 사용하는 할당자를 교체하는 것이다. 이 방식을 사용하는 할당자를 이중 버퍼 메모리 할당자라고 한다. 이를 활용하면 다음 프레임에 현재 프레임에서 한 작업의 결과를 얻을 수 있으면서도 단일 프레임 할당자의 이점을 그대로 챙길 수 있다.  

  - 크기가 다른 객체를 순서 없이 할당과 해제를 반복하면 메모리 단편화가 일어난다. (만약 크기가 일정하다면 풀 할당자를, 순서가 정해져있다면 스택 할당자를 고려하자.) 단편화를 해결하기 위해서는 조각 모음을 해야하는데, 할당된 블록을 가르키는 포인터들이 있다면, 이 포인터들을 모두 찾아서 새로운 주소를 가르키게 해야한다. 그러나 특정 지역을 가르키는 포인터를 찾는 작업은 어려운 작업이다. 그러므로 재배치에 적합한 스마트 포인터나, 핸들을 쓰는 것이 적합하다.

- 캐시 메모리

  - 캐시 메모리는 실행 파일의 명령어 코드가 실행 되기 전 불러오는 데 쓰이는 명령어 캐시 (I 캐시)와, 데이터를 메인 RAM에 읽고 쓰는 속도를 빠르게 하는 데이터 캐시 (D 캐시)로 나뉜다. 이 두 캐시는 물리적으로 분리 되어있기에, I 캐시 미스와 D 캐시 미스 모두 프로그램을 느리게 할 수 있다.

  - I 캐시 미스를 피하는 방법은 다음과 같다.

    - 성능이 중요한 코드는 가능한 기계어 명령어 수가 적게 짜야 한다.

    - 성능에 큰 영향을 미치는 코드에서는 함수 호출을 자제해야 한다.
  
    - 같은 번역 단위에 있는 함수들은 선언되는 순서대로 함수들이 메모리에 배열되기에, 호출해야 하는 함수를 현재 함수와 가까운 곳에 배치해야 한다. 다른 번역 단위에 있는 함수일 경우, 기계어 거리를 보장할 수 없다.

    - 작은 함수를 인라인 함수로 하면, 성능을 향상 시킬 수 있으나, 인라인 함수가 크다면 코드의 크기가 커져 코드가 캐시에 다 들어갈 수 없게 될 수 있으므로, 주의해야 한다.

  - 작은 최적화 팁  
    후위 연산자 대신 전위 연산자를 사용하는 것도 중요한 최적화 기법이다. 전위 연산자는 연산을 끝내고 피연산자의 값을 반환하기만 하면 된다. 그러나 후위 연산자는 연산 전 값을 저장한 후, 연산 후에, 저장한 값을 반환해야한다. 결국 새 것을 생성하고 복사하는 시간이 추가로 소모된다.

- 문자열  
  - 문자열은 가변적인 크기의 문자 배열이므로 처리하는 방식에 따라 게임 전체 성능에 큰 영향을 준다. 그리고 사용자가 볼 수 있는 언어로 번역하는 현지화 역시 문자열을 디자인할 때 신경 써야 할 문제이다.  
  
  - 언리얼 엔진에 FName이나 Java의 String처럼 문자열 해시 값을 문자열 ID를 쓰는 것도 좋은 해결 방안이다. 문자열 ID를 만들어 전역 문자열 테이블에 추가하는 것을 interning이라고 부르기도 한다.  
  문자열 ID를 사용할 경우 interning 함수를 가능한 컴파일 타임에 호출되도록 만드는 것도 좋은 방법이다. 이렇게 하면 사용자는 문자열 내부를 모르고 사용하더라도 즉, 변수로 저장하지 않더라도 성능의 차이가 없으며, 오히려 더 빠른 실행이 보장된다.  
  
  - 현지화는 문자열 DB를 저장하는 것부터 시작한다. 이 DB를 무엇으로 할 지는 자유롭게 선택할 수 있다. 간단한 CSV 파일이 될 수도 있고, 복잡한 Oracle DB가 될 수도 있다. 그러나 핵심은 문자열 DB를 만든 후부터는, 문자열을 직접 노출하지 말고 DB의 문자열 ID를 사용하고, 검색 함수를 통하게 해야한다는 것이다. (문자열 ID를 해시로 하는 것은 어떨까? 현지화와 성능이라는 2마리 토끼 모두 잡을 수 있는 방법인 것 같다.)

- 게임 설정

  - 게임 설정의 핵심은 저장 장치에 저장하고, 게임에서 불러오는 것이다. 설정 정보를 저장하고 불러오는 방법은 여러가지가 있다.
    - INI 파일, XML 파일, JSON 파일 같은 텍스트 파일
    - 압축 바이너리 파일
    - 윈도우 레지스트리 (윈도우 한정)
    - 커맨드 라인 옵션
    - 환경 변수
    - 온라인 서버

  - 게임 설정은 모든 사용자가 읽고 쓸 수 있는 **전역 설정**과 자신만이 읽고 쓸수 있는 **사용자별 설정**으로 구분된다. 당연히 게임 엔진은 두 설정을 모두 지원해야 한다.

  - 설정 정보를 만드는 파일을 제작하는 것은 어떨까? 설정 파일을 컴파일하면 헤더 파일을 만들고, Config Manager는 설정 값들을 구조체 배열로서 불러오는 것이다. 그리고 Config Manager만 볼 수 있는 변수인 ID를 추가하면 사용자는 일반적인 구조체를 다루는 것처럼 설정 파일들을 조작할 수 있을 것이다.

- 제 6회 C++ 세미나를 듣고 생각해보니 메모리 할당자 역시 thread-safe해야 한다는 것을 잊었습니다. 그래서 메모리 할당자를 thread-safe하면서 빠르게 할 까 생각했습니다. 결론적으로 제가 내린 결론은 메모리 할당자를 thread-local하게 선언하는 것입니다. 메모리 할당자는 할당만을 담당하고, 메모리 접근은 다른 스레드에서 할 수 있기 때문입니다. 또 프레임 할당자처럼 다른 스레드에서 접근 중일 때 해제 될 가능성이 있는 할당자는 다른 스레드에서 접근할 가능성이 없다고 생각했습니다. 제가 놓친 것이나, 피드백은 언제나 환영합니다.
