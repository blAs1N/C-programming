# 게임 엔진 아키텍처를 읽고 배운 점 (14장)

- **게임 플레이 기반 시스템 (gameplay foundation system)** 이란 게임의 규칙, 목표, 동적 구성 요소들을 만들 때 쓰이는 런타임 소프트웨어 컴포넌트를 뜻한다. 게임 엔진마다 공통적인 하위 시스템들이 존재한다.

- 런타임 객체 모델 구조
  - 13장에서 상술했듯 에디터 객체 모델 구조와 다를 수도 있지만, 에디터에서 제공된 추상적 객체 모델의 속성, 행동을 게임에서 구현해야 하고, 이것을 런타임 객체 모델 구조라 한다.

  - 객체 모델 구조는 객체 중심적 (object-centric) 모델과 속성 중심적 (property-centric) 모델로 나뉜다.
    - 객체 중심적 모델은 게임 객체 하나를 클래스 인스턴스 1개나 적은 숫자의 인스턴스 집합으로 표현된다.

    - 속성 중심적 모델은 게임 객체는 고유 id로만 표현되며, 속성들은 데이터 테이블에 담겨있고 id 값을 통해 접근한다. 행동은 스크립트 id 등을 활용해서 표현한다.

- 레벨 내부 구성 요소를 저장하고 불러오기 위해서는 데이터 형식을 정의해야 한다.
  - 단순히 런타임에 존재하는 모든 객체의 바이너리 이미지를 파일로 저장하는 방식이 있다. 그러나 C++ 클래스 인스턴스를 저장하려면 포인터와 가상 테이블을 예외적으로 처리해야 하고, 변경이 힘들며 변경 시 문제가 발생할 가능성이 높아 좋은 선택이 아니다.

  - 객체를 직렬화하는 방법이 있다. 객체를 XML 등의 형식으로 직렬화하고, 불러올 때는 역직렬화를 통해 객체를 만든다. 보통 가상 함수로 자신의 클래스를 스스로 직렬화하게 만들거나, 리플렉션 시스템을 구현해 자동으로 직렬화하는 시스템을 만드는 방법을 사용한다.

  - 위 두 방식은 객체 타입이 런타임 구현에 종속적이라 에디터가 런타임 구현을 알아야한다는 단접이 있다. 이를 해결하기 위해 스포너라는 데이터 블록을 레벨 데이터 파일에 있는 게임 객체마다 저장한다. 스포너는 툴에서 쓰이는 객체 타입 id와 속성의 초기값 테이블이 존재한다.

- 레벨을 로딩하는 방법도 여러가지가 존재한다.
  - 단순하게 한 번에 하나의 레벨을 로딩하고 그 동안 단순한 로딩 스크린을 보여주는 방법이 있다. 레벨이 한 개만 존재하기에 스택 기반 할당자를 쓰기 이상적인 방법이다.

  - 에어 락 방식은 단순 레벨 로딩과 비슷하나 로딩 스크린 대신 작은 월드에서 플레이어에게 할 것을 주고 그 동안 새 레벨을 로딩하는 방식이다.

  - 에어 락 지역에 들어가지 않고도 광활한 심리스 월드를 구현 해야 할 때는 스트리밍을 이용한다. 스트리밍에서 주의할 것은 다음과 같다.
    - 게임 플레이 중 어떤 자원을 로딩할지 결정하는 것이다. 단순히 레벨 로드 지역을 만드는 방법이 존재한다. 지역이라 하는 단순 볼륨이 레벨을 겹치게 감싸서 다른 지역으로 가면 지역에 있는 레벨을 로딩하는 방식이다.

- 게임 엔진은 동적인 게임 객체를 생성하고, 파괴할 수 있어야 한다. 게임 객체는 할당과 해제 순서가 정해지지 않고, 크기가 다르기에 힙 할당자를 사용해야 하므로, 단편화가 발생하게 된다. 이를 해결하는 방법은 크게 3가지가 있다.
  - 객체 타입마다 메모리 풀을 따로 만드는 것이다. 이 방법은 단편화는 피할 수 있지만, 여러 풀을 관리해야 하고, 객체 타입별로 얼마나 풀을 만들지 조정해야 한다는 단점이 존재한다.

  - 타입마다 만드는 것과 비슷한 방식으로, 할당 단위가 다른 메모리 풀을 여러 개 만들고, 할당할 때 적합한 메모리 풀을 찾아 할당하는 것이다. 그리고 가장 큰 풀보다 큰 할당 요청은 범용 힙 할당자를 이용하면 된다. 큰 메모리 블록은 단편화가 크지 않으므로 풀에서의 약간의 메모리 낭비를 제외하면 문제가 없는 방법이다.

  - 매모리를 직접 재배치하는 방법이 있다. 자세한 것은 5장에서 상술했다.

- 게임을 저장하는 것은 레벨 데이터 로딩과 비슷하나, 파일의 크기가 훨씬 작아서 데이터 압축과 생략에 더 중점을 두고 따로 구현된다. 게임을 저장하는 방법에는 2가지가 있다.
  - 체크 포인트라 부르는 특정 지점에서만 저장하는 방법이다. 이 경우 체크 포인트 이름, 플레이어 캐릭터 정보만 담으면 되므로 저장 파일의 크기가 매우 작다.

  - 어디서든 자유롭게 저장하려면 게임 플레이에 영향을 주는 모든 게임 객체의 상태를 저장하고, 재시작하면 복원해야 하므로 저장 파일의 크기가 커진다.

- 게임 객체를 찾는 것을 효율적으로 하기 위해 게임 객체 DB를 만들어야 하며, 보통 가장 많이 쓰이는 질의에 효율적인 자료 구조를 사용해서 구현한다. 다음은 자주 사용되는 질의들이다.
  - id로 객체 찾기 : id를 키로 하고 객체를 값으로 하는 딕셔너리를 사용한다.

  - 특정 조건을 만족하는 객체 전체 찾기 : 조건을 미리 알 수 있으면 조건에 맞는 객체를 리스트에 미리 저장하는 방식을 사용한다.

  - 충돌 관련 질의 : 12장을 참고하자.

  - 특정 영역 안의 객체 찾기 : 쿼드 트리, 옥트리 등을 사용한다.

- 실시간 게임 객체 갱신
  - 게임 객체 역시 하부 시스템처럼 갱신해야 한다. 모든 객체마다 갱신하고, 객체 내부에서 하부 시스템을 갱신하는 방식이 존재한다.
    - 이 방식은 일괄 갱신를 통한 성능 향상이 불가능하고, 객체 단위로 처리하면 동작할 수 없는 것들을 해결하기 위해 오히려 더 복잡해질 수 있다는 단점이 존재한다.
  
    - 이를 해결하기 위해 일괄 갱신을 위해 객체에서 하부 시스템 기능을 사용할 때, 자신을 갱신할 것을 요청만 하고, 그 후에 하부 시스템을 일괄적으로 갱신한다.

  - 객체와 하부 시스템은 의존 관계가 존재한다. 즉 의존 관계에 맞춰서 객체의 갱신 순서를 조정해야 한다.
    - 하부 시스템은 단순히 순서에 맞춰서 갱신하도록 코드를 짜면 된다. (5장에서 상술했듯이 매니저 관리 클래스가 이를 자동으로 관리해줘도 좋을 것 같다.)

    - 게임 객체는 매니저 관리 클래스처럼 의존성 트리를 만들어서 갱신 순서를 조정하는 방식을 사용한다. 이 책에서는 같은 깊이의 노드를 갱신하는 방식을 사용하는데, 의존성 트리를 전위 순회하면서 갱신하면 병렬화도 가능할 것 같다.

  - 프레임 갱신 중에 게임 객체가 아직 업데이트하지 않은 객체의 상태를 질의하면 전 프레임 상태를 얻게 된다. 이렇게 업데이트 순서에 문제가 있어서 생기는 버그를 **한 프레임 차 랙** 이라 부른다.

  - 게임 엔진은 병렬 기능을 최대한 활용해서 자원을 최대한 활용해야 한다. 보통 처리하는 데이터가 큰 하부 시스템에 병렬 시스템을 활용하게 된다. 이를 위해 레이 캐스트 같은 하부 시스템 호출을 비동기적으로 해야한다.

  - 게임 엔진은 게임에서 발생하는 이벤트를 C#처럼 연관된 객체가 핸들링하는 시스템이 필요하다. 이벤트는 타입과 전달 인자로 나뉜다.
    - 이벤트의 타입을 구분하는 방법은 크게 3가지가 있다.
      - enum을 활용하는 방법이 있다. 정수므로 단순하고 빠르지만, 모든 이벤트 정보가 한곳에 집중되어 있어 캡슐화가 잘못되었고, 하드 코딩되어있고, 순서에 영향을 받는다는 단점이 있다.

      - string을 활용하는 방법이 있다. 해시를 사용하면 성능과 메모리 사용량을 해결할 수 있으나, 오타나 이름 충돌을 통제할 방법이 없다.

      - 언리얼 엔진과 C#처럼 이벤트를 정의해서 델리게이트로 만들어 타입 비교 자체를 없애는 방법도 있다. (책에는 없음)

    - 전달 인자는 이벤트 베이스 클래스를 상속한 뒤, 멤버 변수로 하드 코딩된다. 아니면 variant의 배열로 저장하는 방법도 존재한다. 이 경우 전달 인자를 할당할 때 풀 할당자를 이용할 수 있다.

    - 이벤트의 처리를 이벤트 큐를 사용해 나중에 처리하도록 할 수 있다.
      - 이벤트 큐의 장점은 크게 3가지가 있다.
        - 이벤트의 처리 시점을 제어해서 안전한 시점에 이벤트의 처리를 유도할 수 있다. (한 프레임 차 렉이 일어나지 않는다.)

        - 전달 시각을 지엉해서 미래에 이벤트를 보낼 수 있다. 이를 다양하게 활용하여 게임을 다채롭게 할 수 있다.

        - 이벤트 처리에 우선 순위를 둘 수 있다.

      - 이벤트 큐의 단점은 크게 3가지가 있다.
        - 즉시 처리보다 이벤트 시스템의 복잡도가 증가된다.

        - 이벤트가 현재 콜 스택을 벗어날 수 있으므로 전달 인자를 깊은 복사해야한다. 즉 동적 메모리 할당을 해야한다.

        - 콜 스택에서 이벤트를 호출한 함수를 볼 수 없어서 디버깅이 어려워진다.

      - (책임 연쇄 패턴을 쓸 경우) 이벤트를 즉시 보내면 깊은 콜 스택이 만들어져 스택 공간이 소진될 수도 있다. 또 이벤트 핸들러 함수가 재진입 가능하게 짜야한다.

    - 이벤트를 데이터 주도적으로 만드는 방법도 여러가지가 있다.
      - 하드 코딩된 이벤트 시스템에 특정 객체의 이벤트 반응 함수 등 단순한 설정만을 지원하는 방법이다.

      - 간단한 스크립트 언어를 지원해서 디자이너가 특정 객체의 이벤트 반응 코드를 만들고, 새 이벤트 타입을 정의하고, 호출하게 만드는 방법이다.

  - 스크립트
    - 스크립트는 2가지로 나뉜다.
      - **데이터 정의 언어** : 엔진에서 사용될 자료 구조를 만들고 값을 넣는데 사용하는 언어로 선언적이고, 주로 오프라인에서 실행된다.

      - **런타임 스크립트 언어** : 런타임에 엔진에서 실행하는 언어로, 게임 객체 모델이나 엔진 시스템을 확장하는데 쓰인다.

    - 스크립트의 구조는 크게 6가지로 나뉜다.
      - 엔진의 중요한 기능을 확장하는데 쓰이는 **스크립트 콜백**

      - 게임 혹은 엔진 내 이벤트에 반응할 때 쓰이는 **이벤트 핸들러**

      - 상속, 합성을 이용해 **게임 객체 타입의 확장** 또는 **새 타입의 정의**

      - **게임 객체의 속성 정의**

      - 객체 모델 전체를 스크립트로 짜서 시스템 호출에만 네이티브 엔진 코드가 쓰이는 **스크립트 주도 엔진 시스템**

      - 스크립트가 모든 것을 주도하고 네이티브 엔진 코드는 라이브러리처럼 호출되는 **스크립트 주도 게임**

    - 스크립트 시스템의 기능은 크게 7가지로 나뉜다. (필수는 아니다.)
      - 네이티브 코드와의 통신 : 보통 필수적으로 구현하는 기능으로, 스크립트 함수의 구현을 네이티브 언어로 구현해서 가상 머신이 네이티브 함수를 찾아내 호출하는 방식을 사용한다.

      - 게임 객체 다루기 : 이 기능을 지원할 경우 스크립트만의 객체 참조 방식이 필요하다. 보통 핸들이나 객체 id를 사용한다.

      - 이벤트 핸들링 : 이벤트 핸들러를 연결하는 방식에 따라서 구현이 달라지는데, 멤버 함수 등을 사용해 클래스에 연결하는 방식과, 멤버 변수 등을 사용해 인스턴스에 연결하는 방식으로 나뉜다.

      - 이벤트 보내기 : 스크립트에서 이벤트를 호출하고, 이벤트를 정의하는 기능이다. 이 기능을 지원하면 스크립트 간 통신이 가능하게 된다.

      - 객체지향 스크립트 언어 : 클래스는 행동과 속성의 모음이므로, 자료 구조를 정의해서 스크립트에서 구현이 가능하다. 상속은 부모 클래스가 스크립트인 것과 네이티브인 것으로 나뉜다. 합성은 스크립트 클래스의 인스턴스를 네이티브에서 퍼스트 클래스 인스턴스와 연결할 수 있으면, 구현이 가능하다.

      - FSM : 스크립트 언어가 FSM을 지원하거나, 스크립트가 각 상태마다 호출되는 스크립트를 구분하는 방식으로 나뉜다.

      - 스크립트 멀티스레드 : 보통 스크립트를 특정 일이 발생할 때까지 잠재우는 기능을 구현함으로서 협력형 멀티태스킹 방식의 스크립트 멀티 스레드를 지원하게 된다.

  - 플레이어의 목적이나 보상, 실패 벌칙 등의 하이레벨 게임 흐름을 조정하는 시스템은 주로 FSM으로 구현된다. 각 상태가 목적이나 도전과제 하나를 나타낸다. 목적을 달성하면 다음 상태로 넘어가며, 목적 실패 시 행동도 정의된다.
