# 게임 엔진 아키텍처를 읽고 배운 것 (10장) - 1

- 테셀레이션  
  - 테셀레이션이란 표면을 여러 개의 분할된 다각형(보통 삼각형)으로 쪼개는 과정이다.

  - 고정된 테셀레이션을 사용할 시 물체의 윤곽이 거칠게 보이는 단점이 있다. 이를 해결하기 위해 카메라와의 거리에 따라서 메시의 픽셀 밀도를 바꾸는 Level Of Detail(LOD)을 사용한다. LOD를 구현하는 방법은 2가지가 있다.
    - 픽셀 밀도가 다른 메시를 여러 벌 만드는 방법이 있다.
    - 고밀도 메시를 하나 만든 뒤, 거리가 멀어지면 메시의 모서리를 없애는 방법이 있다. 이를 점진적 메시(Progressive Mesh)라 한다.

- 메시 정점 리스트  
  - 메시를 정의하기 위해서는 메시를 이루는 정점을 표현해야 한다. 이 방법에는 여러가지가 있다.

  - 제일 기본적인 방법으로, 정점을 세개씩 묶어 리스트로 나타는 것이다. 이 방식의 단점으로는 정점이 중복되는 경우가 많아 메모리가 많이 낭비된다는 것이다.

  - 이를 해결하기 위해서 정점은 중복 없이 나열한 후, 인덱스로만 정의하는 것이다. 이 방법 역시 중복이 있지만, 수 많은 메타 데이터를 저장해야 하는 정점에 비해, 단순한 인덱스이므로 효율적으로 저장할 수 있다.

  - 삼각형 스트립과 삼각형 팬이라는 자료 구조도 있다.
    - 스트립은 첫 정점 3개는 삼각형을 이루고, 이 후 정점은 앞의 정점 2개와 삼각형을 이루는 자료 구조이다.
    - 팬은 첫 정점 3개는 삼각형을 이루고, 이 후 정점은 최초 정점, 그리고 바로 앞의 정점과 삼각형을 이루는 자료 구조이다.

  - GPU는 정점 셰이더를 거친 정점을 캐시에 저장해 재사용한다. 이런 면에서 스트립과 팬은 캐시 일관성을 높일 수 있다는 장점이 존재한다. 그러나 무조건 스트립이나 팬을 쓰지 않아도 정점 캐시 최적화 도구라는 오프라인 툴을 활용해 속도를 향상 시킬 수 있다.
  
- 빛
  - 빛의 색은 강도 I와 파장 λ로 나타낸다.

  - 광선이 각 주파수를 얼마나 포함하는지 그래프로 나타낸 것을 스펙트럼표라고 한다.
  
  - 빛과 물질 간 상호작용
    - 매질과 서로 다른 매질 사이의 경계면의 모양과 속성에 영향을 받는다.

    - 빛은 흡수, 반사, 굴절, 회절만을 한다. (보통 흡수, 반사, 굴절만을 고려한다.)

    - 빛이 반사하면 모든 방향으로 균등하게 퍼지는 난반사(Diffuse)를 하고, 반사광은 그대로 반사되거나, 좁게 퍼지는 정반사(Specular)를 한다.

    - 빛이 비등방(Anisotropic, 방향에 따라 물체의 물리적 성질이 다른 것)일 경우, 산란되거나, 부분적으로 흡수되거나, 굴절된다. 굴절각은 파장에 따라 달라지고, 이로 인해 스펙트럼 확산이 발생한다.

    - 피부 같은 재질에서 피부 안쪽의 재질이나 색깔이 밖으로 비쳐보이는 현상을 표면하산란(Subsurface Scattering)이라고 한다.

- 표면 정보  
  - 표면을 렌더링하려면 표면 법선 방향, 난반사 색상, 반사율, 질감, 투명도, 굴절 정보 같은 정보를 저장해야 한다. 그리고 빛의 작용을 처리하기 위해 빛에 대해 알아야 한다.

  - 보통 정점에 표면의 속성을 저장하는데, 이렇게 나타낸 표면 속성을 정점 속성(Vertex Attribute)이라고 한다. 보통 정점 속성은 다음의 속성들을 담는다.
    - 위치 벡터 : i번째 정점의 3D 위치 (모델 공간 기준)
    - 정점 법선 : i번째 정점의 표면 법선 (단위 벡터), 정점 단위 조명 계산에 사용
    - 정점 탄젠트 : 탄젠트 공간에서의 접선 벡터 T, 픽셀 단위 조명 계산에 사용
    - 바이 탄젠트 : 탄젠트 공간에서 T와 N을 외적한 값, 픽셀 단위 조명 계산에 사용
    - 난반사 색 : 표면의 난반사 색 (보통 Alpha 값을 포함)
    - 정반사 색 : 가상 카메라의 상표면에 맺히는 반사광의 색
    - UV 좌표 : 메시 표면에 붙을 텍스쳐의 좌표, 여러 개의 텍스쳐를 사용할 경우, 아래 첨자 j로 텍스쳐의 인덱스를 표시
    - 스키닝 가중치 : skeletal mesh일 경우 정점이 어느 관절에 연결되어 있고, 얼마나 영향을 받는지 나타내는 수치

- 정점 속성을 저장하는 자료 구조의 레이아웃을 정점 형식(Vertex Format)이라 한다. 만들 수 있는 정점 형식의 수는 이론적으로 무핸대고, 렌더링 엔진이 지원할 수 있는 정점 형식의 수는 한정되어 있기에 보통 일부만 사용할 수 있게 제한하거나, 모든 메시에 단 하나의 수퍼 포맷을 사용한다. (이는 GPU가 정점 자료구조에서 필요한 속성들을 뽑아 내는 기능이 있기에 가능하다.)

- 탄젠트 공간 (책에 안 나와서 인터넷 참조)

  - 접선 공간, 표면 공간, 텍스처 공간으로도 불린다.
  - 텍스처 위에서의 좌표계로, 법선 벡터 (수직 축), 접선 벡터, 바이노멀 벡터를 축으로 한다.

  - 참조한 인터넷 사이트
    - <http://blog.naver.com/PostView.nhn?blogId=sechs2&logNo=120065999816>
    - <https://mgun.tistory.com/1289>

- 셰이딩
  - 정점 속성을 스크린의 픽셀의 속성으로 변화하여 면에 색을 칠하는 것을 셰이딩이라 한다. 셰이딩에는 플랫 셰이딩(Flat Shading), 고로 셰이딩(Gouraud Shading), 퐁 셰이딩(Phong Shading) 등이 있다.
    - 플랫 셰이딩은 면의 법선벡터와 조명벡터로 면의 밝기를 계산한다. 면의 밝기를 계산하기에 물체가 각져보인다.
    - 고로 셰이딩은 정정의 법선벡터와 조명벡터로 정점의 밝기를 계산한다. 이렇게 구한 정점의 밝기를 선형 보간하여 픽셀의 밝기를 계산한다.
    - 퐁 셰이딩은 픽셀의 법선벡터와 조명벡터로 픽셀의 밝기를 계산한다.

- 텍스처
  - 정점 속성을 사용할 때 메시의 삼각형이 지나치게 크면 선형 보간 시 오차가 극명하게 드러나는 한계를 극복하기 위해 비트맵 이미지를 사용하는데 이를 텍스처 맵이라고 한다.

  - 텍스처의 기본 단위를 텍셀이라고 한다.

  - 난반사 맵, 알베도 맵 (PBR의 경우), 법선 맵, 글로스 맵, 환경 맵 등 여러 종류가 있으며, 조명 계산에 필요한 자료는 전부 텍스처에 저장할 수 있다. (1차원 텍스처로 수학 함수의 샘플링 값을 저장하는 것도 가능하다.)

  - 다양한 크기의 텍스처를 지원하기 위해 보통 텍스처 좌표는 (0, 0)에서 (1, 1)로 정규화 하여 사용한다.

  - 텍스처 좌표가 범위를 벗어날 경우 처리하는 방법을 텍스처 주소 지정 방식(Texture Addressing Mode)이라 한다. 4가지의 방법이 존재한다.
    - 반복(wrap) : 모든 방향으로 텍스처를 반복한다.
    - 거울(mirror) : u(v)가 범위를 벗어나는 경우 v(u) 방향으로 텍스처가 반사된다.
    - 고정(clamp) : 범위를 벗어나면 경계 색을 사용한다.
    - 경계 색(border color) : 범위를 벗어나면 사용자가 지정한 색을 사용한다.

  - 압축 텍스처는 비압축 텍스처보다 메모리도 적게 사용하고, 렌더링도 더 빠르다. 그러나 간혹 압축으로 이상하게 보이는 경우도 있다. 보통 눈에 잘 띄지는 않지만 압축 텍스처를 사용하면 안 되는 경우도 있다.

  - 텍셀 밀도와 밉맵
    - 텍셀과 텍스처가 차지하는 픽셀의 비율을 텍셀 밀도라고 한다. 텍셀 밀도는 카메라가 멀어지면 화면에서 차지하는 부분은 작아지나, 텍스처의 크기는 그대로이므로 텍셀 밀도가 커진다.  
  
    - 텍셀 밀도가 1보다 작아지면 텍셀의 경계가 보이므로 사실감이 떨어지고, 1보다 커지면 모이레 패턴이 발생할 수도 있고, 카메라의 위치가 각도가 변하면 색을 결정하는 텍셀이 바뀔 수도 있어 깜빡거릴 수도 있기에 텍셀 밀도를 1에 가깝게 유지해야 한다.

    - 텍셀 밀도를 1에 유지하기 위해 밉맵이라는 기법을 사용한다. LOD와 비슷한 기법으로 텍스처마다 해상도가 절반씩 낮아지는 비트맵을 만들고 (이 비트맵을 밉맵 혹은 밉 레벨이라고 한다.), 거리에 따라 적절한 밉 레벨을 선택한다.

    - 텍스처가 덮인 월드 공간 표면의 비율을 나타내는 **월드 공간 텍셀 밀도**라는 용어도 존재한다. 월드 공간 텍셀 밀도는 1에 맞출 필요는 없지만, 물체들이 일관된 월드 공간 텍셀 밀도를 갖게 해야한다.

    - 텍스처 맵을 샘플링할 때, 픽셀 하나가 텍셀 여러 부분에 해당할 때는 여러 텍스처를 샘플링해 이것들을 블렌딩해 최종 텍셀 색을 결정하는데, 이를 텍스처 필터링이라고 한다. 4가지의 방법이 존재한다.

      - 근접 샘플(Nearest Neighbor) 필터링 : 픽셀 중심과 가장 가까운 텍셀을 쓴다. 밉맵은 최적 해상도보다 큰 밉맵을 쓴다.

      - 이중선형(Bilinear) 필터링 : 픽셀을 둘러싼 네 개의 텍셀들을 샘플링해 이것들을 가중평균한다. 밉맵은 가장 가까운 밉맵을 쓴다.

      - 삼중선형(Trilinear) 필터링 : 가까운 두 밉맵 모두에 이중선형 필터링을 한 후, 그 결과를 선형 보간한다.

      - 비등방성(Anisotropic) 필터링 : 이중선형과 삼중선형이 비스듬히 볼 때는 자연스럽지 않기에, 바라보는 각도에 맞게 사다리꼴 영역에 들어가는 텍셀들을 샘플링해 품질을 향상한다.

- 머터리얼
  - 메시의 시각적인 속성을 통틀어 일컫는 용어이다.

  - 텍스처를 비롯한 하이레벨 속성들, 셰이더 프로그램, 셰이더 인자 등을 포함한다. 정점 속성은 메시에 포함되기에 포함되지 않는다.

  - 메시와 머터리얼만 있으면 물체를 렌더링하는 모든 정보를 갖췄기에, 메시와 머터리얼을 합쳐 **렌더 패킷**이라 부른다. 또는 **기하 기본 단위**를 메시와 머터리얼까지 확장해 쓰기도 한다.

  - 모델은 보통 여러 머터리얼을 사용하기에 메시 하나를 여러 하부 메시로 나눠 각각 머터리얼을 하나씩 연결하는 경우가 많다.

- 빛 수송 모델
  - 빛 수송 모델이란 빛-표면 및 빛-공간 간 상호작용에 관한 다양한 수학적 모델을 말한다.

  - 빛이 방출돼 물체 하나에만 반사된후 바로 카메라 상 표면에 맺히는 직접 조명만 계산에 넣는 것을 지역 조명 모델이라고 한다. 이 경우 물체들은 서로 외관에 영향을 주지 않는다.

  - 지역 조명에서 여러 표면에 여러 번 반사된 간접 조명을 계산에 넣은 것을 전역 조명 모델이라 한다. 레이 트레이싱이나 라디오시티 등이 대표적인 예시이다.

  - 전역 조명은 1986년 J.T.Kajiya가 발표한 SIGGRAPH 논문에서 소개된 렌더링 방정식이라는 수학적 공식에 의해 기술된다.  
  <https://en.wikipedia.org/wiki/Rendering_equation>

  - 전역 조명 모델 중 흔히 사용되는 것은 퐁 반사 모델로 환경(ambient)항 + 난반사(diffuse) 항 + 정반사 (specular) 항으로 표현된다.  
  퐁 반사 모델에 필요한 입력은 다음과 같다.
    - 시선 벡터 V
    - 환경광 강도 (RGB) A
    - 광선이 부딪힌 표면의 법선 N
    - 환경 · 난반사광 · 정반사광 반사율 k<sub>a</sub>, k<sub>d</sub>, k<sub>s</sub>
    - 반짝이는 정도를 나타내는 반사 지수 α
    - 각 광원 i마다 필요한 정보
      - 빛의 색과 강도(RGB) C<sub>i</sub>
      - 반사 지점에서 광원으로의 방향 벡터 L<sub>i</sub>

  - 특정 지점에서 반사되는 빛의 강도  
    I = k<sub>D</sub> + Σ<sub>i</sub>[k<sub>D</sub>(N · L<sub>i</sub>) + k<sub>S</sub>(R<sub>i</sub> · V)<sup>α</sup>]C<sub>i</sub> 이다.

  - R<sub>i</sub>은 N을 기준으로 광선의 방향 벡터를 나타낸 것이다.  
  R = L<sub>N</sub> - L<sub>T</sub> = L<sub>N</sub> - (L - L<sub>N</sub>) = 2(N · L)N - L 라는 수식으로 얻을 수 있다.

  - 블린-퐁(Blinn-Phong) 모델은 반사광 계산식이 변형된 퐁 모델이다. 사선 벡터 V와 빛 방향 벡터 L의 정가운데 있는 벡터 H를 정의하고, 반사광 식 (R · V)<sup>α</sup>가 (N · H)<sup>a</sup>로 바꿔진다.  
  지수 a는 퐁 모델의 지수 α와 다르나, 반사광 항과 비슷한 값이 되게 고른다.  
  블린-퐁 모델은 정확도가 떨어지나, 속도가 더 빨라 초기 PC 게임에서 사용되었다.

  - 퐁 모델을 이루는 항들은 사실 양방향반사도분포함수(Bidirectional Reflectance Distribution Function, BRDF)의 모델 중 하나이다. BRDF는 V를 따라 나가는 빛의 양 : L로 나가는 빛의 양을 계산한다. 보통 반구형 그래프로 나타내며 원점과의 거리를 통해 해당 방향에서 바라본 반사광의 강도를 나타낸다.

- 광원을 모델링할 때는 단순한 모델을 사용한다.
  - 정적 조명(Static Lights) : 픽셀 단위의 조명도를 조명 맵이라는 텍스처 맵에 저장하고, 이것을 투영해 조명 효과를 낸다.
  
  - 환경광(Ambient Lights) : 방향 개념이 없이 색 하나로 나타내며, 퐁 모델에 Ambient항에 해당한다. 환경광 강도, 색은 게임 월드 내 지역마다 다를 수 있다.

  - 방향광(Directional Lights) : 대표적 예시로 태양이 있으며, 광선이 평행하고, 구체적 위치가 없다. 색 C와 방향 벡터 L로 나타낸다.

  - 점(전방향)광원 (Omni-Directional Lights) : 구체적인 위치에서 전방향으로 빛을 낸다. 빛의 강도는 광원과의 거리의 제곱에 반비례해 줄어들고, 최대 거리를 넘기면 0이 된다. (보통 범위 안에 있는 표면만 조명을 적용한다.) 위치 P, 빛의 색 C, 최대 범위 r<sub>max</sub>로 나타낸다.

  - 스팟광원 (Spot Lights) : 점광원과 비슷하나 빛의 범위가 원뿔 모양이다. 추가로 안쪽 원뿔과 바깥 원뿔을 정의해 안쪽에서 벗어나 바깥으로 갈 수록 강도가 광원광의 거리에 반비례해 줄어든다. 위치 P, 빛의 색 C, 중심 방향 벡터 L, 최대 반지름 r<sub>max</sub>, 안 · 바깥 원뿔 각도 θ<sub>min</sub>, θ<sub>max</sub>로 나타낸다.

  - 면적광원 (Area Lights) : 광원이 한 점이지 않고 면적이 있어서 완전히 어두운 부분(umbra)과, 완전히 어둡지 않은 부분(peumbra)이 생긴다. 보통 직접 모델링하지 않고, 그림자를 여러 개 만들어 블렌딩하거나, 그림자의 경계를 둔하게 만드는 방법을 사용한다.

  - 발광체 (Emissive Objects) : 발광 텍스처맵(Emissive Texture Map)으로 표면의 발광을 모델링하고, 스팟광원으로 빛을 비추고, 빛 기둥은 반투명 원뿔형 메시, 카메라를 바라보는 투명한 판으로 렌즈 플레어, 투영 텍스처로 플래시가 비추는 표면에 초곡면(Caustic) 효과를 줘 제작한다.
  
- 가상 카메라
  - 가상 카메라의 원점은 뷰 공간이라 불리는 3D 좌표계의 원점으로, 보통 z축의 양의 방향(왼손 좌표계)이나 음의 방향(오른손 좌표계)을 바라보고, y축은 위, x축은 오른쪽(왼손 좌표계)이나, 왼쪽(오른손 좌표계)이 된다.

  - 뷰 좌표계를 월드 좌표계로 변환하는 것은 모델 좌표계와 다를 것 없이 뷰 월드 행렬을 구하여 변환하면 된다.

  - 메시를 렌더링할 때는 월드 공간 좌표를 뷰 공간 좌표로 변환해야 한다. 이 때 월드 뷰 행렬이 필요한데, 뷰 월드 행렬의 역행렬이다.
  
  - 보통 모델 월드 행렬과 월드 뷰 행렬을 결합해 모델 뷰 행렬을 만들어 행렬 곱셈을 줄인다.

  - 투영은 3D 장면을 3D 평면에 렌더링할 때 사용하는 특수한 변환이다. 보통 2가지의 투영을 사용한다.
    - 원근 투영 (Perspective Projection) : 물체가 카메라에서 멀리 떨어질수록 작아 보이는, 원근 단축(Perspective Foreshortening) 효과가 적용된다.

    - 직교 투영 (Orthographic Projection) : 길이가 보존되어, 평면도를 렌더링하거나 HUD를 렌더링할 때 쓰인다.

  - 뷰 볼륨 (View Volume)
    - 카메라가 볼 수 있는 영역을 뷰 볼륨이라 한다. 뷰 볼륨은 평면 6개로 정의되며, 옆 평면 4개가 스크린의 경계를 이루고, 근 폄면은 가상 감광 표면에 해당하고, 원 평면은 너무 멀리 있는 물체를 그리지 않는 최적화의 목적으로 사용된다.
  
    - 원근 투영은 위가 잘린 피라미드 모양인 절두체(Frustum)가 되고, 직교 투영은 직육면체 프리즘 모양이 된다.

    - 뷰 볼륨의 평면들은 4차원 벡터 (n<sub>xi</sub>, n<sub>yi</sub>, n<sub>zi</sub>, d) 6개로 표현할 수 있는데, n은 평면 법선이고, d는 원점과의 거리이다. 평면 위 임의의 점 Q<sub>i</sub>와 평면 법선 n<sub>i</sub>으로 나타낼 수도 있다.

  - 동차 클립 공간 (Homogeneous Clip Space)
    - 뷰 공간을 변형한 3차원 공간으로, 카메라 공간 뷰 볼륨을 투영 종류, 스크린 해상도, 화면 비율에 무관하게 변경 가능하기 위해 사용한다.

    - 원근 투영과 직교 투영은 뷰 공간의 점을 동차 클립 공간으로 변환한다.

    - 보통 직육면체 프리즘 형태이며, x축과 y축은 -1 ~ 1에, z축은 -1 ~ 1(OpenGL)이나 0 ~ 1(DirectX)에 걸쳐있다.

    - 동차 클립 공간은 일반적으로 왼손 좌표계이므로, z축이 스크린 안쪽을, x축은 오른쪽을 향한다.
  
    - 점 p[p<sub>Vx</sub> p<sub>Vy</sub> p<sub>Vz</sub> 1]를 원근 투영 행렬과 곱하면 [a b c -p<sub>pVz</sub>]가 된다. 이를 점 벡터로 바꾸기 위해서는 x, y, z를 w와 나눠야 하므로 동차 클립 공간으로 변환된 점 p<sub>H</sub>는 [p<sub>Hx</sub> p<sub>Hy</sub> p<sub>Hz</sub>]가 되어 원근 단축 효과가 생긴다.

    - 정점 속성 보간 역시 원근 투영 후 원근 단축 효과를 감안해야 한다. 이 과정을 원근 보정 속성 보간이라고 한다. 공식은 <sup>A</sup>/<sub>p<sub>z</sub></sub> = (1 - t)<sup>A<sub>1</sub></sup>/<sub>p<sub>z1</sub></sub> + t <sup>A<sub>2</sub></sup>/<sub>p<sub>z2</sub></sub> = LERP(<sup>A<sub>1</sub></sup>/<sub>p<sub>z1</sub></sub>, <sup>A<sub>2</sub></sup>/<sub>p<sub>z2</sub></sub>, t)이다.

  - 동차 클립 공간의 좌표가 정규화된 단위 사각형 안이 아닌 스크린 공간에 위치하게 스케일하고 이동하는 것을 스크린 매핑이라고 한다.

  - 래스터화 (rasterization)
    - 삼각형의 이미지를 화면에 그리기 위해선 삼각형이 걸친 픽셀을 채워야하는데, 이를 래스터화라고 한다. 래스터화가 진행되는 동안 삼각형의 표면을 단편(fragment)이라 불리는 조각들로 쪼개는데, 각 단편은 스크린의 한 픽셀에 들어가는 삼각형의 표면 영역을 나타낸다.

    - 단편은 몇 번의 테스트를 통과해야 프레임 버퍼에 기록되거나 기존 픽셀의 색과 블렌딩되고, 단 한 번이라도 테스트에 실패하면 버려진다.

- 안티앨리어싱 (antialiasing)
  - 삼각형의 모서리가 거칠게 보이는 '계단 현상'을 감소시키는 기법으로, 삼각형의 모서리와 모서리를 둘러싼 프레임 버퍼의 색들을 블렌딩한다.

  - full-screen antialiasing(FSAA)은 실제 스크린보다 가로세로 두 배 넓은 프레임 버퍼에 렌더링한 후, 다운 샘플한다. 픽셀의 개수가 4배이므로 굉장히 느리고, 메모리도 4배 더 차지한다.

  - multisample antialiasing(MSAA)은 한 픽셀을 두 개 이상의 단편으로 쪼개고 파이프라인의 끝에서 한 개의 픽셀로 합친다. 메모리의 크기도 증가하지 않으며, 성능 상의 이슈도 크지 않다.

- 차폐와 깊이 버퍼(depth buffer, z-buffer)
  - 그리는 순서에 관계없이 삼각형이 차폐되기 위해서 렌더링 엔진은 깊이 버퍼를 사용한다.

  - 깊이 버퍼는 화면과 같은 크기의 버퍼로 각 픽셀마다 16비트나 24비트 부동소수를 저장하며, 단편이 가지고 있는 z 좌표와 비교에 단편이 카메라에 더 가깝다면 프레임 버퍼에 기록하고 깊이 버퍼를 갱신한다.

  - Z-다툼(Z-Fighting)과 W 버퍼
    - 굉장히 가까운 표면들을 렌더링할 경우 정밀도의 한계로 깊이 값이 같아져 먼 평면의 픽셀들이 가까운 평면을 뚫고 들어오는 Z-다툼 현상이 생긴다.
  
    - 해결하려면 카메라의 거리에 관계 없이 똑같은 정밀도를 가져야 하지만 클립 공간 z버퍼는 뷰 공간 z 좌표의 역수이므로 가까운 지점에 정밀도가 할애되어, 먼 지점에서는 z-다툼이 발생하게 된다.

    - 즉 p<sub>Hz</sub> 대신 p<sub>Vz</sub>를 깊이 버퍼에 저장해야 하는데, 이 값은 클립 공간 좌표에 w 성분으로 표현되므로 이를 w 버퍼 기법이라고 한다. (클립 공간의 z는 뷰 공간의 1/z를 저장하고, w는 뷰 공간의 z를 저장한다는 것이다.)

    - w 버퍼 기법은 깊이 값을 직접 선형 보간할 수 없기에 보간 전에 깊이 값의 역수를 구하고, w 버퍼에 저장하기 전에 다시 역수로 바꾸는 비용이 든다.
  