# 게임 엔진 아키텍처를 읽고 배운 것 (10장) - 2

- 렌더링 파이프라인
  - 파이프라인의 각 단계는 독립적으로 동작하므로 병렬화에 유리하다.

  - 파이프라인의 처리량(throughput)은 초당 처리할 수 있는 데이터 아이템의 개수이고, 지연시간(latency)는 한 데이터 아이템이 파이프라인을 통과하는데 걸리는 시간이다. 파이프라인의 처리량은 가장 느린 단계에 좌우되며, 평균 지연시간도 영향을 미친다.
  
  - 렌더링 파이프라인을 이 책에서는 오프라인 툴까지 포함해 5단계로 나누었다.
    - 툴 단계(오프라인) : DCC 프로그램으로 콘텐츠를 제작한다. 스키닝을 할 수 있는 메시면 정점에 연결된 관절과 가중치 역시 지정해야 한다. 머터리얼을 개별 메시와 함께 저장하면 데이터와 작업이 중복되므로, 대부분 소수의 머터리얼을 정해 놓고 여러 물체에 적용한다.

    - 자원 다듬기 단계(오프라인) : 리소스를 엔진에서 쓸 수 있게 가공하는 단계로 6장을 참고하자. 보통 플랫폼 독립적으로 만들어 저장하고, 그 후 플랫폼 종속적인 형식으로 변환해 사용한다. 정적 조명을 굽는 것 역시 이 단계에 포함된다.

    - 애플리케이션 단계(CPU) : 보일 가능성이 있는 메시 인스턴스를 판별하고 머터리얼과 함께 그래픽 하드웨어에 보내 렌더링할 수 있게 하는 단계로, 그 외에도 셰이더 인자와 렌더 상태를 제어하거나 기하 형상들을 정렬하는 등 빠른 렌더링을 위한 보조 작업을 한다.

    - 기하 형상 처리 단계(GPU) : 좌표를 동차 클립 공간으로 투영하고, 조명을 적용한다. 후술할 절두체 클리핑을 할 수도 있다.

    - 래스터화 단계(GPU) : 삼각형을 단편들로 쪼개 색을 결정하고, 다양한 테스트를 거쳐 프레임 버퍼에 블렌딩한다.

  - GPU 파이프라인
    - GPU 역시 여러 개의 단계로 파이프라인을 나눈다. (옛날 책이라 최신 파이프라인은 아니지만, 참고용으로 정리했습니다.)
      - 정점 셰이더 : 정점을 동차 클립 공간으로 변환하고 색을 결정하고, 조명을 적용하는 단계이다.

      - 지오메트리 셰이더 : 동차 클립 공간에 있는 모든 기본 단위를 처리하며, 추려내거나 수정하거나 새로운 기본 단위를 만든다.

      - 스트림 출력 : 지금까지 처리된 데이터를 다시 메모리에 저장하고, 처음으로 돌아가 추가적인 처리를 하는 단계이다.

      - 클리핑 : 절두체에 걸친 삼각형의 일부를 자르고, 교차한 부분을 정점으로 하여 새로운 삼각형을 만드는 단계이다.

      - 스크린 매핑 : 동차 클립 공간에 있는 정점을 스크린 공간으로 스케일하고 이동하는 단계이다.

      - 삼각형 셋업 : 효율적인 래스터화를 위해 하드웨어를 초기화하는 단계이다.

      - 삼각형 순회 : 래스터화를 진행하는 단계로, MSAA을 하면 픽셀 하나에 여러 단편을 만든다.

      - 이른 Z 테스트 : 픽셀 셰이더를 거치기 전에 확실히 그려지지 않는 단편을 버려서 성능을 향상 시키는 단계이다.

      - 픽셀 셰이더 : 단편의 색을 결정하고, 투명한 텍스처를 버리거나, 픽셀 단위 조명 계산을 하는 등 다양한 작업을 한다.

      - 합치기/래스터 작업 단계 : 래스터 동작 단계나 ROP라고도 한다. 깊이 테스트, 알파 테스트, 스텐실 테스트 등 다양한 테스트로 단편을 걸러내고, 프레임 버퍼에 있는 색과 블렌딩하는 단계이다.  
      알파 블렌딩은 반투명한 기하 형상을 렌더링하는데 쓰이며 다음과 같은 블렌딩 함수를 사용한다.  
      C<sup>'</sup><sub>D</sub> = A<sub>S</sub>C<sub>C</sub> + (1 - A<sub>S</sub>)C<sub>D</sub>  
      C<sub>S</sub>는 입력 단편이고, C<sub>D</sub>은 프레임 버퍼의 픽셀이다. A<sub>S</sub>는 입력 단편의 알파 값이다.  
      알파 블렌딩으로 그린 것이 제대로 보이려면 불투명한 기하 형상을 그린 후, 반투명 표면을 정렬하여 뒤에서 앞으로 그려야 한다.

- 셰이더
  - 셰이더는 한 개의 입력 단위를 받아 0개 이상의 단위를 출력한다.

  - 셰이더는 RAM을 직접 읽고 쓸 수 없지만, 레지스터나 텍스처 맵을 이용해 메모리에 접근한다.
    - 셰이더 레지스터는 128비트 SIMD 형식으로, 4가지 종류가 있다.
      - 입력 레지스터 : 셰이더의 입력 데이터를 받는 레지스터로 셰이더 호출 이전 GPU가 데이터를 입력한다.

      - 상수 레지스터 : 상수 값을 저장하는 레지스터로, 모델-뷰 행렬 같은 온갖 매개변수들을 담는다. 애플리케이션이 렌더링 이전에 값이 채워지게 된다.

      - 임시 레지스터 : 셰이더 프로그램 안에서 사용하며 보통 중간 계산 값을 담는다.

      - 출력 레지스터 : 출력 값을 저장하는 레지스터로, 셰이더가 채워 넣는다. 그 후 RAM에 저장되어 다음 파이프라인 단계로 넘어간다. 보통 출력 데이터를 캐시에 넣어서 재사용한다.
    - 텍스처 맵은 읽기 전용 데이터로 직접 읽기가 가능하며, 메모리 주소가 아닌 텍스처 좌표로 접근한다. GPU의 텍스처 샘플러가 인접 텍셀이나 인접 밉맵을 알아서 가져와 블렌딩한다. 원래 값을 가져오고 싶다면 텍스처 필터링을 끄면 된다. 값을 쓰고자 할 때는 프레임 버퍼에 렌더링 한 뒤, 다음 렌더링 패스에서 텍스처 맵으로 인식하게 하는 방법을 사용하며, 이를 '텍스처에 렌더링'한다고 말한다.

    - 보통 셰이더 프로그램 자체만으로는 한계가 많아서 셰이터 프로그램들을 엮고, 전역 변수들을 설정하는 등의 작업을 하여 **이펙트 파일**을 제작한다.

- 애플리케이션 단계 중에서도 보일 가능성이 있는 물체들을 고르는 작업 즉 절두체 밖으로 완전히 벗어난 물체들을 렌더링 리스트에서 제외하는 작업은 다양한 방법이 존재한다.
  - 절두체 안에 있는지 판단하는 방법은 절두체의 각 평면마다 평면을 구의 반지름만큼 안쪽으로 이동한 뒤, 메시의 중심이 평면의 앞에 있는지 검사하면 된다. 이를 **절두체 선별 (Frustum Culling)** 이라 한다.

  - 절두체 안에 있어도 다른 물체에 가려질 수 있기에, 이 것 역시 리스트에서 제거해야 한다. 이를 **차폐 선별 (Occlusion Culling)** 이라 한다.
    - 차폐 선별은 많은 물체가 밀집해 있다면 중요하지만, 위에서 내려다보거나, 물체가 멀리 떨어져 있다면 오히려 차폐 선별로 인해 느려질 수도 있다.

    - 선별하는 방법으로는 Potentially Visible Set(PVS)이 존재한다. PVS란 카메라가 바라보는 위치가 주어지면 보일만한 물체들을 알려주는 시스템이다. 보통 레벨을 나누고, 각 지역에서 보일만한 다른 지역을 리스트로 가지게 만들어 구현한다.

    - 레벨이 실내 환경일 경우 **포탈(Portals)** 이라는 방식도 같이 쓰이는데, 밀폐된 지역으로 레벨을 구분하고, 다른 지역으로 연결되는 부분을 포탈이라 부른다. 그 후 카메라에 보이는 지역의 포탈마다 카메라의 초점에서 포탈의 모서리들로 이어지는 평면들을 만들어 절두체 모양의 포탈 볼륨을 만들어 절두체처럼 이용한다.

    - 포탈의 개념을 뒤집어 물체에 가려 보이지 않는 지역을 나타낼 수도 있다. 이를 **차폐 볼륨(Occlusion Volumes)** 혹은 **안티포탈(AntiPortals)** 이라 한다. 가리는 물체의 경계 모서리를 찾아 초점에서 모서리를 지나는 평면을 만들어 차폐 볼륨을 만들게 된다.

  - 게임 월드가 넓다면 절두체 검사 방식은 비효율 적이므로 장면 그래프라는 자료 구조를 사용해 빠르게 선별한다. (장면 그래프이지만 주로 트리를 사용한다.) PVS처럼 공간을 나눠서 절두체 안에 있는지 검사하게 된다. 장면 그래프도 다양한 자료 구조가 존재한다.
    - 쿼드 트리는 재귀적 방식으로 공간을 4분할하고, 분할된 공간이 절두체와 교차하는지 검사하고, 교차할 경우 재귀적으로 공간을 4분할해 검사하는 것을 반복하게 된다. 보통 단말 노드의 기본 단위의 개수가 균등해질 때까지 반복하게 된다.

    - 옥트리는 쿼드트리를 3차원에 적용한 것으로, 8분할하게 된다.

    - 경계 구 트리는 사각형 형태 대신 구 형태로 나누게 되며, 트리의 단말 노드는 기본 단위의 경계 구를 나타낸다.

    - BSP 트리는 주로 과거 화가 알고리즘으로 렌더링할 때 사용하던 알고리즘으로, 공간을 반으로 나누며, 나눈 절반이 특정 조건을 충족할 때까지 반복하게 된다. 나누는 기준은 보통 특정한 삼각형을 포함하는 평면이다. 나눈 뒤에는 카메라의 앞에 있으면 이진 트리의 좌측 자식, 뒤에 있으면 우측 자식으로 설정하고, 이 방식을 반복해 이진 트리를 만든다.

  - 기본 단위 리스트를 제작한 뒤에는 리스트를 GPU에 제출해야 한다. 그 전에 GPU 파이프라인 중 설정 가능한 단계의 설정을 해야 한다. 이런 인자들을 렌더 상태라고 한다. 보통 메시에 연결된 머터리얼에서 모든 정보를 제공하므로, 리스트의 메시 인스턴스를 돌며 머터리얼에 기술된 대로 렌더 상태를 설정하고, 제출하게 된다.

  - 렌더 상태를 기술할 때 빠뜨린 것이 있으면 이전 기본 단위에 쓴 상태가 다음 상태를 그리는 데 영향을 미치는, 렌더 상태 누수가 발생하게 된다.

  - 렌더 상태 설정은 전역이므로 렌더 상태를 변경할 때마다 성능의 저하가 발생하므로, 가능한 적게 바꿔야 한다. 이를 위해 기하 형상들을 머터리얼로 정렬하는 방법이 존재한다. 그러나 머터리얼을 기준으로 기하 형상을 정렬하면 필요 없는 그리기가 증가되어 성능이 저하된다. 성능을 최대한 높이기 위해서는 삼각형을 앞에서 뒤로 그려야 한다.

  - 머터리얼로 정렬해야 하는 문제와 앞에서 뒤로 그려야 하는 문제를 해결하는 방법은 GPU의 z 프리패스라 불리는 기능이다. z 프리패스는 2번의 렌더링을 하게 된다.
    - 첫 번째 렌더링에서는 픽셀 셰이더를 끄고 z 버퍼만 갱신하는 렌더링 모드를 이용해, 렌더 상태를 변경하지 않아고 앞에서 뒤로 그려서 빠르게 z 버퍼를 갱신한다.
  
    - 두 번째 렌더링에서는 머터리얼을 기준으로 기하 형상을 정렬한 후 정상적으로 렌더링하게 된다. 이 때는 이미 z 버퍼가 채워져 있어 중복으로 그리지 않는다.

- 고급 조명 기법
  - 이미지 기반 조명
    - 텍스처 맵을 활용하여 조명 하는 것을 이미지 기반 조명이라 한다. 이 책에서는 5개의 기법이 존재한다.
      - 법선 매핑 : 각 텍셀마다 표면 법선 방향을 나타는 벡터를 담는다. 정점 법선을 통해 제공할 경우 높은 레벨의 테셀레이션이 필요하다. () 법선 맵을 사용하면 테셀레이션을 하지 않고 표면의 법선을 구할 수 있다.

      - 높이 맵 : 삼각형 표면의 높낮이를 담는 텍스처 맵으로, 텍셀 당 높이 하나면 되므로 그레이스케일 이미지로 담긴다.

      - 정반사/광택 맵 : 정반사 강도 수식인 k<sub>S</sub>(R · V)<sup>α</sup>의 k<sub>S</sub>값을 저장하는 것을 정반사 (광택) 맵이라고 부른다. α 값도 저장할 수 있는데, 이를 통해 정반사 하이라이트의 집중도를 조정할 수 있다. 이런 텍스처 맵을 정반사 지수 맵이라고 부른다.

      - 환경 매핑 : 주위 환경이 표면에 반사되는 것을 구현하기 위해 사용하며, 주변 환경을 텍스처에 저장하고 표면에 텍스처를 입힌다. 구형 환경 맵과 큐브 환경 맵으로 나뉘고, 주로 큐브 맵을 사용한다. 큐브 맵은 해당 물체를 중심으로 6방향을 저장해 환경 맵에 저장한다.

      - 3차원 텍스처 : 3차원 텍스처는 2차원 텍스처를 쌓은 것으로 3차원 좌표가 주어지면 GPU가 알아서 찾고, 필터링한다. 보통 물체의 외형을 기술하거나 용적에 관한 속성을 나타낼 때 사용한다.
  
  - HDR 조명은 색 강도가 1을 넘어로 저장하고, 렌더링하기 전에 색조 매핑을 통해 강도를 장치 허용 범위로 매핑한다. 1을 넘어서 표현해야 하므로 32비트 부동 소수로 저장하거나, 다른 색 모델을 사용한다. 보통 16비트고 이진 로그로 저장되는 명도 채널(L)과 각각 8비트인 색도 채널 두 개(U, V)로 표현하는 logLUV 모델을 사용한다.

  - 전역 조명에서 처리하는 효과들은 표면끼리 가릴 때 생기는 그림자, 반사, 초곡면 등이 있다.
    - 게임에서 사용하는 광원은 점이므로 그림자의 경계가 분명하다. 그러나 실제 그림자는 반암부(penumbra)라 불리는 경계가 흐릿한 부분이 생긴다. 그렇기에 다른 렌더링 기법이 필요한데, 그림자 볼륨과 그림자 맵이라는 기법이 존재한다.
      - 그림자 볼륨은 광원에서 차폐볼륨처럼 그림자가 지는 부분을 찾아 그림자 볼륨을 만든다. 그 후 스텐실 버퍼에 앞면인 부분은 1을 증가시키고, 뒷면인 부분은 1을 감소시킨다. 그 후에 스텐실 버퍼가 0이 아닌 곳을 그림자 처리하면 그림자가 생기게 된다.

      - 그림자 맵은 광원의 시점에서 렌더링한 후, 깊이 버퍼를 이용해 그림자 맵 텍스처를 만들어 두 번째 렌더링에서 이를 이용해서 그리면 된다.

      - 그림자 구현은 현재 다른 기법이 많다. 참고하도록 하자.  
      <https://www.slideshare.net/MoonLightMS/1023-1>

    - 환경 광 차폐는 표면의 각 지점에 전체 빛이 도달한 강도를 나타내는 것이다. 표면의 한 점을 중심으로 하는 큰 반구를 만들어 반구의 지역들이 보이는 비율을 계산한다. 정적인 물체는 텍스처 맵으로 저장할 수 있다.

    - 반사 효과는 반짝이는 물체에 반사되는 것과 거울같은 표면에 반사되는 것으로 나뉜다.
      - 반짝이는 물체에 대강 반사하는 것에는 환경 맵을 사용한다.

      - 거울같은 표면에 반사되는 것은 카메라의 위치를 반사 표면에 대칭시킨 뒤, 장면을 텍스처에 렌더링하고, 두 번째 패스에서 텍스처를 표면에 입히는 식으로 구현된다.

    - 초곡면 효과는 물이나 금속에서 발생하는 매우 밝은 정반사 하이라이트로, 랜덤한 하이라이트를 담은 텍스처를 표면에 투영하는 식으로 구현된다.

    - 표면하 산란은 빛이 표면 아래에서 산란한 후 다른 지점에서 밖으로 나오는 것을 뜻한다. 보통 BRDF 중 하나인 BSSRDF로 기술한다. 효과를 내는 방법 중 하나로 깊이 맵 기반 표면하 산란 방식이 있다. 물체에서 그림자가 지는 부분에 빛이 물체를 통과하는데 걸리는 거리에 반비례해 난반사 성분을 준다. 통과하는데 걸리는 거리에 반비례하므로 얇은 부분만 효과를 줄 수 있다.

    - PRT는 입사광의 표면에 작용되는 것을 모든 방향에서 미리 계산하고 저장하는 방식으로, 특정 입사 광선이 주어지면 대응 값을 찾아내 정확한 조명 결과로 변환한다.

  - 지연 렌더링 (Deferred Rendering)
    - 통상적인 삼각형 렌더링은 연산을 한 뒤에 단편을 버려야하므로, 비 효율적이다. 그리고 다수의 광원이 있는 복잡한 장면을 처리하려면 수많은 셰이더가 필요하다.

    - 이를 해결하기 위해 고안된 것이 지연 렌더링으로, 렌더링을 할 때 조명을 고려하지 않고 그니다. 이 과정에서 픽셀 조명에 필요한 모든 정보를 G 버퍼에 저장한다. 렌더링이 끝나면 G 버퍼를 이용해 스크린 공간에서 조명과 셰이딩 계산을 한다. G버퍼는 여러 버퍼들의 모음이다. 보통 깊이, 표면 법선, 난반사 색, 정반사 지수 등을 포함한다.

- 시각 효과와 오버레이
  - 파티클
    - 쿼드같은 단순한 기하 형상들로 이뤄진다.
    - 항상 카메라를 향사도록 처리해야 한다.
    - 거의 반투명하므로 렌더링 순서를 지켜야 한다.
    - 다양한 방식으로 애니메이션된다. 애니메이션 곡선이나, 절차적 방식으로 정의한다.
    - 계속 스폰되고 사라진다. 파티클 이미터는 월드에서 지정 속도로 파티클을 생성하며, 파티클은 조건이 충족되면 없어진다.

  - 데칼
    - 일반적인 기하 형상들의 표면에 씌우는 기하 형상이다.
    - 데칼을 사각형 영역으로 모델링한 후, 화면에 일직선으로 투영하는 방식으로 구현한다. 이 방식을 사용하면 직육면체 프리즘이 생기고, 가장 먼저 교차한 표면에 데칼을 입힌다. 시차 매핑으로 깊이감을 주고, z 다툼을 방지하기 위해 z 값을 조정한다.

  - 하늘
    - 단순하게 하늘을 렌더링하는 방법으로는 3D 형상 렌더링 이전에 프레임 버퍼에 하늘 텍스처를 넣는 것이다. 텍셀 밀도가 1이 되기 위해 화면의 해상도와 비슷하게 텍스처를 만든다. 그리고 프레임 버퍼의 깊이 값을 최대한 크게 해 모든 장면이 하늘 위에 그려지게 해야한다.

    - 플레이어가 모든 방향을 볼 수 있으면 돔 형태나 박스 형태의 하늘을 만들어 카메라의 위치를 중심으로 렌더링하는 방식을 사용한다.

  - 텍스트/폰트
    - 폰트는 보통 사용하는 자체들을 모아 텍스처 맵으로 만들어 구현한다. 폰트 정보가 담긴 파일은 텍스처 맵 내부 자체 경계 박스같은 폰트 위치 정보를 제공한다.

    - 다양한 언어의 문자 셋의 차이와 읽기 방향 역시 처리해야 한다. 글자를 움직이거나, 애니메이션을 지원하는 경우도 있다.

  - 풀 스크린 후처리 효과 (post Effects)
    - 렌더링된 장면에 사실성을 더하거나 효과를 내는 역할을 한다.

    - 스크린 전체의 내용을 픽셀 셰이더를 통과시켜 적용한다.

    - 모션 블러, DoF 블러, 비그넷, 채색 효과 등이 Post Effects에 해당한다.
