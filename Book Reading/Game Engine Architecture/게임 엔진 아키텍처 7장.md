# 게임 엔진 아키텍처를 읽고 배운 것 (7장)

- **타임 라인**이란 1차원 축으로, 다른 타임 라인을 기준으로 원하는 위치에 원점을 위치 시킬 수 있다. (나는 이 것을 좌표계를 1차원으로 했다고 생각했다.) 타임 라인은 정수나 부동소수 타입의 간단한 변수로 저장된다.

- 타임 라인은 많은 종류가 있다. 실제 시간을 나타낼 수도 있고, 게임을 플레이한 시간이 될 수도 있으며, 애니메이션이나 오디오 클립을 조작할 때 타임 라인을 사용할 수도 있다.

- 타임라인을 사용했을 때 장점들은 다음과 같다.
  - 게임 시간을 느리게 하거나 정지할 수 있어서 디버깅에 도움이 된다.
  - 애니메이션이나 오디오의 속도를 변화하거나, 거꾸로 할 수도 있다.

- 게임을 실행하다가 중단점에 도달해 게임 루프를 멈춘 뒤, 다시 실행하면 델타 타임은 어떻게 될까? 중단점에서 한 시간도 델타 타임에 포함이 되어 다음 프레임을 시작하게 된다. 엔진 시스템이 정상적으로 실행되지 않을 것이라는 것은 당연한 결과이다. 이 문제를 어떻게 해결할 수 있을까? 간단한 방법이 있다. **게임 루프에서 프레임 시간이 정해둔 한계를 벗어나면 멈췄다가 실행했다고 간주하고 델타 타임을 목표 프레임 레이트로 강제 설정하는 것이다.** 이 방법을 통해서 프레임 레이트 스파이크를 방지할 수 있다.

- 멀티프로세서 콘솔은 어떤 구조로 되어 있는지 알아보자.
  - Xbox 360은 세 개의 동일한 PPC 코어가 있고, 각각 L1 I 캐시와 L1 D 캐시가 있다. 세 코어와 GPU는 통합된 512MB 메모리 풀을 공유한다.

  - PS3는 메인 CPU인 PPU와 6개의 SPU라 부르는 코프로세서가 있다. PPU는 I 캐시와 D 캐시가 있고, SPU는 256kB 크기의 메모리인 로컬 스토어가 있다. PPU만이 접근 가능한 256MB의 메인 메모리가 존재하는데, SPU는 DMA 컨트롤러가 메인 메모리와 로컬 스토어를 중계함으로서 메모리에 간접적으로 접근한다.

- 멀티 프로세서 하드웨어를 활용하는 방법에는 3가지가 존재한다.

  - 분할 정복 알고리즘을 활용하는 방법으로, 분기/결합 방식이라고 부른다. 일을 작게 쪼개어 스레드에 분배하고, 작업이 끝나면 결과를 합치는 방식이다.

  - 엔진 하부 시스템을 별도의 스레드에서 작업하게 하는 방식이다. 그러나 각 스레드가 큰 단위에 작업을 처리해야 해서, 제 시간에 일을 끝내지 못하면 다른 스레드의 진행도 멈추는 단점이 존재한다.

  - 위에 문제를 해결하기 위해서 게임 엔진이 처리하는 작업들을 여러 개의 작고 독립적인 task로 나눠서 실행하는 방식이 있다. task는 작고 독립적이기에 프로세서를 최대한 활용할 수 있고, 효과적인 스케일링을 보장한다.

- 멀티플레이어 게임 모델은 C-S 모델과 P2P 모델이 존재한다.

  - C-S 모델은 게임 로직의 대부분이 서버에서 실행되고, 클라이언트는 입력을 일고, 로컬 플레이어를 조정하고, 렌더링만 하게 된다. 로컬 플레이어는 입력이 즉시 반영되도록 주의해야 한다.  
  보통 서버 업데이트는 클라이언트가 3번 업데이트 될 때마다 하게 된다.

  - P2P는 게임에 참가한 모든 노드가 조금씩 서버의 역할을 맡는다. 자신이 담당하는 객체와 다른 노드가 관리하는 객체를 구분하는 기능이 필요하고, 다른 노드가 나가거나 들어올 때의 처리를 해야한다.
  