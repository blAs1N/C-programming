# 게임 엔진 아키텍처를 읽고 배운 것 (6장)

- 파일 시스템
  
  - OS의 API를 감쌌을 때의 장점
  경로를 표현하는 방법도 OS마다 차이가 존재하므로, 일관성을 보장하기 위해서라도 OS의 함수를 감싸야 한다. 그 외에도 감쌀 경우 추가적인 장점이 존재한다.
    - 다른 플랫폼이라도 똑같은 동작을 보장할 수 있다.
    - 엔진에서 필요한 기능만 갖게 단순화할 수 있다.
    - 확장 기능을 지원할 수 있다. (대표적으로 비동기 파일 I/O)

  - CWD  
  CWD란 UNIX, Windows에서 모두 지원하는 개념으로, 현재 작업 디렉터리 (Current Working Directory)의 약자이다. 상대 경로는 CWD부터 시작하는 경로이다. (절대 경로는 CWD가 루트 디렉터리인 것이다.)

  - 비동기 파일 I/O (Streaming)  
  표준 C 라이브러리의 파일 I/O는 모두 동기적으로 동작한다. 그러나 게임 엔진은 비동기적인 파일 I/O를 지원해야 한다.  
  Streaming이 지원해야 할 기능은 다음과 같다.  
    - 비동기적 I/O
    - I/O 동작이 완료되기를 기다리는 기능
    - 비동기 I/O에 우선순위를 부여하는 기능

  - 비동기 파일 I/O의 구현 방법  
  Streaming은 생산자-소비자 패턴을 활용하여 구현하게 된다. I/O가 끝날 때까지 기다리는 기능은 세마포어를 이용해서 구현할 수 있다.

- 리소스 매니저
  
  - 게임에서 사용하는 자원 중 원래 형식을 그대로 쓸 수 있는 것이 별로 없기에, 게임에서 쓸 수 있게 하는 **Asset Conditioning Pipeline (ACP)** 을 거쳐서 사용한다.

  - ACP는 다음 단계를 거친다. (일부 단계만 거쳐도 되는 리소스들도 있다.)

    - 내보내기 도구 (Exporter)  
    **리소스의 고유 형식을 게임 엔진에서 다룰 수 있는 형식으로 변환한다.** 보통 해당 리소스의 플러그인을 만드는 방법을 사용한다. 이렇게 만들어진 파일은 ACP의 다음 단계에 전달된다.

    - 리소스 컴파일러  
    **원본 데이터를 게임에서 사용하기 위해 조작하는 단계이다.** (메시의 삼각형을 스트립으로 재배열 하거나, 텍스처 비트맵을 압축하는 등의 과정이다.)

    - 리소스 링커  
    **불러오기 전 여러 리소스 파일들을 하나의 패키지로 묶는 단계이다.**

  - ACP를 거치는 자원들은 자신을 어떻게 처리해야 해야 하는지 알려주는 메타 데이터가 존재한다. 이런 메타 데이터를 관리하기 위해서는 **리소스 데이터베이스** 가 필요하다. 리소스 데이터베이스는 설정처럼 다양한 데이터베이스를 선택할 수 있다.

  - 리소스 데이터베이스는 다음과 같은 기능을 제공해야 한다.
    - 일반적인 데이터베이스처럼 삽입, 삭제, 조회, 수정이 가능해야 한다. 일관된 방식으로 처리할 수 있으면 가장 좋다.
    - 리소스의 원본 파일을 옮길 수 있어야 한다.
    - 리소스들끼리 교차 참조할 수 있으면서, 참조 무결성을 유지해야 한다.
    - 변경 사항을 관리하고, 작업자와 작업 사유에 대한 기록을 갖춰야 한다.
    - 다양한 질의를 처리할 수 있으면 좋다.

  - 리소스를 관리하는 방법에는 하나의 파일로 모아 관리하는 방법과 모으지 않고 디스크에 두고 관리하는 방법이 있다. 하나의 파일로 모아 관리할 경우, ZIP 파일같은 여러 복합 파일을 이용한다. 디스크에 두고 관리할 경우, 디렉토리 트리로 관리하는 경우가 일반적이다.  

- 리소스는 관리를 위해서 **GUID** 가 필요하다. 보통 GUID는 리소스의 경로를 사용한다. (문자열을 그대로 사용하거나, 해시를 사용한다.) 하지만 하나의 파일로 모으는 방식을 사용할 경우, 경로를 사용할 수 없기에 고유하게 지정한 GUID를 사용할 수도 있다.

- 같은 리소스를 여러번 메모리에 적재하는 것은 낭비기에, 리소스 매니저는 한 리소스가 한 번만 메모리에 적재되도록 관리한다. 대부분 리소스 레지스트리를 두어 관리하게 된다. 보통 GUID를 키로 두고, 리소스의 메모리 주소가 값이 된다.  

- 리소스를 요청할 때 리소스가 없을 경우 2가지 방법이 존재한다.
  
  - 그냥 실패 코드를 반환하는 것이다. 이렇게 하면 사용자는 지금 리소스를 불러올지, 다른 작업을 할지 자유롭게 선택할 수 있다.

  - 리소스를 자동으로 불러오는 방법이 있다. 자연스러운 방법이지만, 리소스를 불러오는 작업은 시간이 많이 걸리는 작업이기에, 사용자는 **메모리에 있는 리소스를 불러오는 작업에서 게임의 프레임이 떨어지거나, 게임이 멈추는 결과를 보게 되는 것이다.** 이런 이유로 다음 2가지 중 하나를 선택하게 된다.
    - 게임 플레이 중에 리소스 로드를 금지한다.
    - 리소스를 비동기적으로 불러온다.

- 리소스 매니저는 리소스의 할당과 해제 즉, 리소스의 수명을 관리해야 한다. 리소스의 수명은 여러 종류가 있다.
  - 게임이 시작할 때 할당하여 게임이 끝날 때까지 항상 메모리에 상주하는 리소스가 있다. 이것을 **load-and-stay-resident (LSR)** 리소스라고 부른다.
  - 특정 레벨의 수명을 따라가는 리소스가 있다.
  - 재생되기 전 할당했다가, 끝나면 바로 해제하는 리소스가 있다. 대표적으로 인게임 컷신이나 오디오 클립이 있다.
  - 재생하면서 실시간으로 스트리밍하는 리소스가 있다. 배경 음악이나, 환경 사운드 효과, 풀 스크린 동영상 등이 있다. 이런 리소스는 하드웨어가 요구하는 크기만큼 덩어리로 불러오는데, 메모리에는 현재 재생 중인 덩어리와, 다음 재생을 위해 불러오고 있는 다음 덩어리 만이 존재한다.

- 여러 레벨에 걸쳐 공유되는 리소스는 메모리를 해제할 시점을 결정하기 어렵다. 이를 해결하기 위해 스마트 포인터처럼 리소스에 참조 카운트를 붙이는 방법을 사용한다.

- 리소스에 메모리를 할당하는 방법 중 리소스를 똑같은 크기의 덩어리로 불러오는 방법이 있다. 이 방식을 사용할 경우, 풀 할당자와 마찬가지로 단편화를 해결할 수 있다. 그러나 이 방식을 사용하기 위해서는 모든 리소스 데이터가 똑같은 크기의 덩어리로 나뉠 수 있게 해야하므로, 한 덩어리 안에 들어갈 만한 작은 자료 구조를 사용하거나, 연결 리스트를 사용하는 방법이 있다.

- 풀 할당자를 사용할 경우 리소스의 크기가 정확히 풀 크기의 배수가 되지 않는다면 마지막 덩어리는 낭비되게 된다. 이를 해결하기 위해 쓰지 않는 부분을 특수한 메모리 할당자를 쓰는 방법이 있다. 그러나 그 풀이 해제된다면 할당한 메모리도 자동으로 해제되는 단점이 있다. 이를 해결하는 방법으로는 리소스의 수명과 일치하는 할당 요청만 사용하는 방법이 있다.

- 복합 리소스
  
  - 각 리소스들은 다른 리소스를 참조하는 경우가 많기 때문에, 리소스 데이터베이스는 리소스 간 의존 관계를 표현하는 방향 그래프를 사용해서 나타내는 경우가 많다.
  
  - 리소스끼리의 상호 참조는 같은 파일 안에 있는 리소스를 참조하는 내부 참조와 다른 파일끼리 참조하는 외부 참조로 구분된다.

  - 상호 참조하는 리소스를 한데 묶어 복합 리소스라고 부르기도 하며, 이 경우 상호 참조가 모두 복합 리소스 안에서 처리된다.
  