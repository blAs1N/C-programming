# 게임 엔진 아키텍처를 읽고 배운 것 (8장)

- 게임이 HID로부터 입력을 받고 출력을 보내는 방법은 여러 가지가 있다.
  
  - 하드웨어를 주기적으로 폴링하는 방식으로 읽어오는 방식이 있다.  
  하드웨어 레지스터 혹은 메모리 맵 I/O 포트를 직접 읽거나 하이레벨 소프트웨어 인터페이스를 통하는 방법이 있다.

  - 컨트롤러의 상태가 변할 때만 하드웨어 인터럽트를 통해 통신하는 방법이 있다.

  - 무선 장치는 레지스터나 메모리 맵 I/O 포트로 데이터를 읽고 쓸 수 없기에 블루투스 프로토콜을 통해 장치와 교신한다. 보통 별도의 스레드에서 처리한다.

- 게임 엔진 HID 시스템의 일반적인 요구 조건들은 이런 것이 있다.
  
  - 아날로그 축은 잡음으로 인해 오차가 있을 수 있기에 값이 0이어도 0이 아닐 수가 있다. 그래서 최소값 주변에 데드 존을 두어 데드 존 이하이면 0으로 처리하게 한다.

  - 데드 존 범위 밖에 있어도 잡음을 처리해야한다. 잡음 신호는 사람이 내는 신호에 비해 고주파인 경우가 많아 저역 통과 필터를 거치게 한다.
  저역 통과 필터는 <https://en.wikipedia.org/wiki/Low-pass_filter>을 참고하자.

  - 현재 입력 값이 아닌 버튼을 눌렀을 때 등의 이벤트를 감지해야 한다. 보통 이전 프레임의 값을 저장한 후 이 값과 비교하는 방식을 사용한다.  
  
  - 동시에 눌러서 특수 행동을 하는 버튼 그룹인 **코드 (chord)** 역시 지원해야 한다. 이 때 주의할 점이 있다.
    - 개별 버튼 다운과 코드를 동시에 실행하지 않게 주의해야 한다.
    - 완전히 동시에 누를 수 없기에 최초 입력 후 몇 프레임 이내 나머지 버튼을 감지할 수 있어야 하고, 그 동안 개별 버튼 역시 처리해야 한다.

  - 연타나 격투 게임의 콤보 시스템을 제작할 때 사용하는 제스처를 지원해야 한다.

    - 연타는 최근에 눌린 시각을 기록하여 제작한다. 그 후 입력을 받으면, 현재 시간 - 최근에 눌린 시간을 계산하여 제한 시간을 넘기지 않았는지 확인하여 구현한다.

    - 제스처는 최초 시간을 기록하고, 버튼 id의 배열을 정의하여 현재 입력이 올바른 입력인지 확인하고, 현재 시간 - 최초 시간이 제한 시간을 넘기지 않았는지 확인하여 구현한다.

  - 여러 개의 HID를 연결해 멀티플레이어 게임을 플레이 할 경우 각각의 입력을 올바른 플레이어에 전달되게 해야 한다.

  - 컨트롤러 전원 코드가 뽑히거나, 배터리가 나가는 등의 상황에 대처해야 한다. 배터리로 동작하는 HID를 사용할 경우, 낮은 배터리 상황도 감지해야 한다.

  - 크로스플랫폼을 지원해야 한다. 보통 별도의 추상화 계층을 두어 해결한다. (언리얼 엔진은 이 계층을 활용하여 크로스플랫폼을 지원하고, 입력의 재배치와, 입력의 이름을 설정할 수 있게 하였다.)

  - 수직 축 방향을 바꿀 수 있게 하는 것처럼 컨트롤러의 기능을 플레이어가 조정할 수 있어야한다. 보통 위의 문제처럼 추상화 계층을 두어 해결한다.

  - 플레이어가 조작하지 못하게 만들 필요가 있을 때를 위해 입력을 무시하는 기능이 필요하다. 입력 자체를 무시할 경우, 입력을 받는 모든 부분에 영향을 줄 수 있기에, 보통 특정 액터가 입력을 무시하도록 한다.
