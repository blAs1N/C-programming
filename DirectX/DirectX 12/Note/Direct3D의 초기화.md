# DirectX 기본 지식

## DirectX란  

응용 프로그램에서 GPU를 제어하고 프로그래밍하는 데 쓰이는 저수운 그래픽 API이다.  
DirectX 12는 CPU 부담을 줄이고, 다중 스레드 지원을 개선하기 위해 DirectX 11보다 GPU에 가까운 API가 되었다. 즉 DirectX 11보다 어려워진 대신 성능이 개선되었다.

## COM (Component Object Model)

DirectX의 프로그래밍 언어적 독립성과 하위 호환성을 만들어주는 하는 기술로 COM 인터페이스라고 부른다. 세부 사항들은 프로그래머에게 보이지 않아서 생성하는 함수가 무엇인지만 알고 있으면 된다.  
소멸 시에는 delete 구문을 사용하지 않고, Release 함수를 호출한다. Com 객체의 메모리 관리 방식은 shared_ptr처럼 Release 시 참조 횟수를 감소시키며, 참조 횟수가 0이 되면 Com 객체가 메모리에서 해제된다.  
수명 관리를 돕기 위해 WRL (Windows Runtime Library)에 ComPtr이라는 스마트 포인터 클래스가 있다. 이 포인터는 범위를 벗어나면 자동으로 Release를 호출한다.  
Com 인터페이스들은 이름이 I로 시작한다.  

## 텍스쳐 형식

텍스쳐는 1, 2, 3차원까지 텍스쳐가 존재하며, N차원 텍스쳐는 N차원 배열이다. 주된 용도는 이미지 자료의 저장이지만, 법선 매핑이라는 고급 기법에서는 3차원 벡터를 담기도 하는 등 범용적으로 쓰인다.  
텍스쳐 원소 형식들은 8가지가 있는데 DXGI_FORMAT_(원소 크기)_(원소 타입)의 이름을 가진다. (ex. DXGI_FORMAT_R32G32B32_FLOAT은 32비트 부동소수점 성분 4개로 되어있다.)  
이 외에도 DXGI_FORMAT 열거형은 정점 자료, 색인 자료 형식의 서술에도 사용된다.

## 교환 사슬과 페이지 전환

그리는 중에 생기는 깜빡임을 막는 방법 중에 화면에는 보이지 않는 텍스쳐에다 그린 후, 완성된 텍스쳐를 화면에 표시해서, 사용자는 완성된 화면만 보게 하는 방법을 이중 버퍼링이라고 한다.  
이중 버퍼링을 위해서는 두 개의 텍스쳐 버퍼가 필요한데 이를 각각 전면 버퍼와 후면 버퍼라고 부른다. 화면에는 전면 버퍼의 이미지를 보여주고, 그 동안 후면 버퍼에서 다음 프레임을 그린 뒤, 두 버퍼의 역할을 맞바꾸는 것을 반복하며 하나의 교환 사슬을 형성하게 된다..  
이렇게 역할을 교환해서 페이지를 전환하는 것을 DirectX에서는 제시 (Presenting)이라고 하는데, 포인터만 맞바꾸는 것이라 굉장히 효율적이다. WinAPI에서 이중 버퍼링을 구현할 때 후면 버퍼의 내용을 전면 버퍼에 복사하는 것과 대비되는 내용이였다.  

## 깊이 버퍼링 (Z 버퍼링)

깊이 버퍼란 이미지를 담지 않는 텍스처의 한 예시로, 이미지 대신에 각 픽셀의 깊이 정보를 담게된다. 깊이는 0.0 ~ 1.0이며, 수치가 작을 수록 더 가까운 물체이다. 각 픽셀의 깊이 정보를 담아야 하므로 깊이 버퍼의 원소의 개수는 후면 버퍼의 원소의 개수와 같고, 각 원소가 일대일로 대응한다.  
본론으로 돌아가서 깊이 버퍼링이란 물체가 거리에 따라서 뒤에 있는 물체는 가려지게 만들어주는 알고리즘으로, 화가 알고리즘과 해결하고 하는 문제는 같지만, 화가 알고리즘의 문제들 (물체가 많으면 오래 걸린다. 맞물린 형태의 물체는 제대로 처리할 수 없다.)에서 자유롭고, 굉장히 효율적이다.  
방법은 처음에는 그려야하는 픽셀의 깊이를 1.0으로 설정한다. 그 다음 그 픽셀을 놓고 경쟁하는 오브젝트의 깊이 값을 보고 현재 픽셀의 깊이보다 작을 경우에는 그 픽셀을 갱신하게 된다.  
이런 방법으로 그리는 물체에 순서를 상관하지 않고 올바른 픽셀을 고를 수 있다.  

## 자원과 서술자

렌더링 과정에서 GPU는 자원들에 자료를 읽거나 기록하는데, 그리기 명령을 제출하기 전에 그리기 호출이 참조할 자원들을 렌더링 파이프라인에 묶어야한다.  
하지만 자원을 직접 묶는 것은 그 자원을 어느 단계에서 써야하는지를 모르고, (하나의 자원을 여러 단계에서 사용하게 될 수도 있고, 자원이 무형식일수도 있다.) 자원의 일부분만 필요할 경우에도 전부 다 묶어야한다는 여러 단점이 있어서 해당 자원을 참조하는 서술자를 묶게된다.  
서술자는 GPU에게 서술하는 경량의 자료구조로, GPU와 자원 사이에 간접층을 형성해서 상술한 단점을 해결한다.  
서술자는 여러 종류가 있다. 대표적으로 CRV, SRV, UAV, RTV, DSV 등이 있다.  
서술자 힙은 서술자들의 배열으로, 배열처럼 각 서술자마다 다른 서술자힙이 필요하지만, 같은 종류의 서술자힙이 하나만 있어야하는 것은 아니다.  
서술자들은 응용 프로그램의 초기화 시점에 생성해야한다. 왜냐면 그 때 형식 점검과 유효성 검증이 일어나기 때문이다.  

## 다중표본화 (MMSA)

안티 앨리어싱을 하는 방법 중 하나로, 다른 방법인 초과표본화가 픽셀 처리량과 메모리 소비량이 굉장히 높아서 DirectX는 절충점인 다중표본화를 사용한다.  
다중표본화는 초과표본화가 하는 것처럼 후면 버퍼와 깊이 버퍼를 4배 크게 잡지만, 초과표본화처럼 모든 부분 픽셀마다 계산하지 않고, 픽셀당 한 번만 계산 후에, 색상과 부분 픽셀들의 가시성, 포괄도를 이용해 색을 결정하게 된다.  
DirectX에서 다중표본화를 하려면 DXGI_SAMPLE_DESC라는 구조체를 채워야 하고, 최대 수준을 알기 위해서는 CheckFeatureSupport이라는 함수를 사용한다.  

## 기능 수준

사용자의 GPU가 어떤 버전까지의 DirectX를 지원하는가를 D3D_FEATURE_LEVEL이라는 열거형으로 표현하며, 이 것을 이용해 사용자가 특정 수준을 지원하지 않으면 더 낮은 수준으로 후퇴하여 사용자층을 넓일 수 있다.  
기능 수준을 점검하기 위해서는 MSAA에서도 쓴 CheckFeatureSupport이라는 함수를 사용한다.  

## DXGI (DirectX Graphics Infrastructure)

Direct3D와 함께 쓰이는 API로 여러 그래픽 API들에 공통인 그래픽 관련 작업을 처리하는 함수들이 있다. 대표적으로 전체 화면 모드 전환, SwapChain 인터페이스 생성, 그래픽 시스템 (GPU, 모니터, 디스플레이 모드) 등을 열거하는 함수가 있다.  

# CPU와 GPU의 상호작용

## 명령 대기열과 명령 목록

GPU는 명령 대기열에 있는 명령들을 처리하는데, CPU는 그리기 명령들이 담긴 명령 목록들을 제출한다. 그러나 GPU는 해야할 명령 목록들이 있기에 바로 처리되지는 않는다.  
명령 대기열이 비게 되면 GPU가 놀게 되고, 명령 대기열이 꽉 차게 되면 CPU가 놀게 되므로, 둘 다 쉬지 않고 돌아가게 하기 위해 잘 구성해야 한다.  
명령 대기열을 생성하기 위해서는 D3D12_COMMAND_QUEUE_DESC 구조체를 채워서  CreateCommandQueue 함수를 호출해야한다.  
명령을 대기열에 추가하기 위해서는 ExecuteCommandLists 함수를 호출하는데, 명령 목록을 제출하기 전에, ID3D12GraphicsCommandList에 Close 메서드를 호출해 명령 기록이 끝났음을 알려야한다.  
명령 목록들은 ID3D12CommandAllocator 형식의 메모리 할당자에 저장되어 대기열에서는 할당자에 담긴 명령들을 참조하게 되며, 메모리 할당자의 생성은 ID3D12Device 클래스의 CreateCommandAllocator 메서드를 사용한다.

## CPU / GPU 동기화

CPU와 GPU를 동기화하는 방법은 명령 대기열의 명령 목록을 다 처리할 때까지 CPU가 대기하는 것으로, 이를 명령 대기열을 방출한다라고 하며, 이 때 울타리라는 객체가 필요하다. 울타리 객체는 ID3D12Device 클래스의 CreateFence 함수를 사용한다.  

## 자원 상태 전이

GPU에서 자원에 자료를 기록하기 전에 자료를 읽으려 하면 문제가 생기면 이를 자원 위험 상황이라 부른다.  
이를 해결하기 위해 Direct3D는 자원에 상태를 부여해서 GPU가 상태를 보고 자원 위험을 피하는데 필요한 조치를 취하게 한다. 이 때 상태 전이는 성능을 위해서 전적으로 응용 프로그램의 책임이다.  
자원 상태 전이는 전이 자원 장벽들의 배열을 선언해서 지정하며, 배열이라서 한 번에 여러 개의 자원 전이가 가능하다.

# DirectX의 초기화

1. D3D12CreateDevice 함수로 ID3D12Device를 생성한다.  
2. ID3D12Fence 객체를 생성하고 서술자들의 크기를 얻는다.  
3. 4X MSAA 품질 수준 지원 여부를 점검한다.  
4. 명령 대기열과 명령 목록 할당자, 그리고 주 명령 목록을 생성한다.  
5. 교환 사슬을 서술하고 생성한다.  
6. 응용 프로그램에 필요한 서술자 힙들을 생성한다.  
7. 후면 버퍼의 크기를 설정하고, 후면 버퍼에 대한 렌더 대상 뷰를 생성한다.  
8. 깊이 스텐실 버퍼를 생성하고, 그와 연관된 깊이 스텐실 뷰를 생성한다.  
9. 뷰포트와 가위 판정용 사각형들을 설정한다.

뷰표트란 장면을 창 전체에 그리는 것이 아닌 일부 직사각형 영역에만 그릴 때, 그 영역을 지정하는 직사각형으로, 유니티와 언리얼 엔진에서 사용하는 그 뷰포트이다.  

가위 직사각형은 특정 픽셀들은 선별하는 용도로 쓰이며, 렌더링 시 가위 직사각형의 바깥 픽셀들은 후면 버퍼에 래스터화되지 않아서 최적화에 도움을 준다. 다른 모든 것을 가리는 직사각형 UI 요소가 화면 특정 영역에 있으면 그 부분은 처리할 필요가 없는 것이 대표적 예시이다.

# 시간 측정

애니메이션이나 그 외 로직을 정확히 처리할 때 사용한다. (유니티의 Time.deltaTime, 언리얼의 DeltaTime)  
시간을 측정하기 위해 Win32 함수인 QeuryPerformanceCounter와 QueryPerformanceFrequency를 사용한다.  
측정하는 값들은 시작한 시간, 정지된 시간, 최근 정지한 시간, 현재 시간, 지난 프레임 시간이다.  
정지된 시간은 시작한 시간을 빼서 플레이 시간을 구하는데 사용하고, 지난 프레임 시간은 현재 시간에서 빼서 프레임 처리에 걸린 시간을 구한다.  
플레이 시간을 구할 때는 정지된 상황이면 최근 정지한 시간 - 정지한 시간 - 시작한 시간이고, 플레이 중이면 현재 시간 - 정지한 시간 - 시작한 시간이다.  
FPS (Frame per Second)와 한 프레임 당 걸린 시간 중 한 프레임 당 걸린 시간이 더욱 유용하다. 왜냐면 걸린 시간이 훨씬 직관적으로 파악할 수 있고, FPS의 변화는 선형적이지 않기 때문이다. (1000 FPS -> 250 FPS와 100 FPS -> 77 FPS로의 변화는 전부 3 ms의 증가지만, 1000 FPS ->  250 FPS로의 감소가 더욱 심해보인다.)  
한 프레임 당 걸린 시간은 FPS의 역수이다.  
이 책에서는 Win32 함수를 호출해서 시간을 측정했지만, 나는 표준인 chrono를 사용할 것이다.